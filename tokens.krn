PROGRAM_START, @:!
FUNCTION_DEFINITION, super:def
TYPE, int
IDENTIFIER, fibonacci
LEFT_PAREN, (
TYPE, int
IDENTIFIER, n
RIGHT_PAREN, )
START_STATEMENT, :
BLOCK_START, {
VARIABLE_DEFINITION, def:
TYPE, int
IDENTIFIER, a
ASSIGN, *>>*
NUMBER, 0
COMMAND_END, ;
VARIABLE_DEFINITION, def:
TYPE, int
IDENTIFIER, b
ASSIGN, *>>*
NUMBER, 1
COMMAND_END, ;
VARIABLE_DEFINITION, def:
TYPE, int
IDENTIFIER, temp
COMMAND_END, ;
IF_CONDITIONAL, i:
LEFT_PAREN, (
IDENTIFIER, n
LESSER_EQUAL, =<<=
NUMBER, 1
RIGHT_PAREN, )
START_STATEMENT, :
RETURN, yeet
IDENTIFIER, n
COMMAND_END, ;
BLOCK_END, }
ELSE_CONDITIONAL, e:
BLOCK_START, {
FOR_LOOP, f:
LEFT_PAREN, (
VARIABLE_DEFINITION, def:
TYPE, int
IDENTIFIER, i
ASSIGN, *>>*
NUMBER, 2
COMMAND_END, ;
IDENTIFIER, i
LESSER_EQUAL, =<<=
IDENTIFIER, n
COMMAND_END, ;
IDENTIFIER, i
INCREMENT, *++*
RIGHT_PAREN, )
START_STATEMENT, :
BLOCK_START, {
IDENTIFIER, temp
ASSIGN, *>>*
IDENTIFIER, a
SUM, *+*
IDENTIFIER, b
COMMAND_END, ;
IDENTIFIER, a
ASSIGN, *>>*
IDENTIFIER, b
COMMAND_END, ;
IDENTIFIER, b
ASSIGN, *>>*
IDENTIFIER, temp
COMMAND_END, ;
BLOCK_END, }
COMMAND_END, ;
RETURN, yeet
IDENTIFIER, b
COMMAND_END, ;
BLOCK_END, }
BLOCK_END, }
COMMENT,   comentario de exemplo
FUNCTION_DEFINITION, super:def
TYPE, void
IDENTIFIER, main
LEFT_PAREN, (
RIGHT_PAREN, )
START_STATEMENT, :
BLOCK_START, {
VARIABLE_DEFINITION, def:
TYPE, int
IDENTIFIER, num
COMMAND_END, ;
DATA_OUTPUT, put::
LITERAL_STRING, "Digite o numero de termos:"
COMMAND_END, ;
DATA_INPUT, read:
IDENTIFIER, num
COMMAND_END, ;
DATA_OUTPUT, put::
LITERAL_STRING, "Serie de Fibonacci: "
COMMAND_END, ;
FOR_LOOP, f:
LEFT_PAREN, (
VARIABLE_DEFINITION, def:
TYPE, int
IDENTIFIER, i
ASSIGN, *>>*
NUMBER, 0
COMMAND_END, ;
IDENTIFIER, i
LESSER_EQUAL, =<<=
IDENTIFIER, num
COMMAND_END, ;
IDENTIFIER, i
INCREMENT, *++*
RIGHT_PAREN, )
START_STATEMENT, :
BLOCK_START, {
DATA_OUTPUT, put::
IDENTIFIER, fibonacci
LEFT_PAREN, (
IDENTIFIER, i
RIGHT_PAREN, )
COMMAND_END, ;
DATA_OUTPUT, put::
LITERAL_STRING, ", "
COMMAND_END, ;
BLOCK_END, }
BLOCK_END, }
PROGRAM_END, %:!
